<Mods LoadCommand = "%xero(function(self)
	if not P1 or not P2 then
		backToSongWheel('Two Player Mode Required')
		return
	end

	GAMESTATE:ForceSmoothLines(1)

	-- judgment / combo proxies
	for pn = 1, 2 do
		setupJudgeProxy(PJ[pn], P[pn]:GetChild('Judgment'), pn)
		setupJudgeProxy(PC[pn], P[pn]:GetChild('Combo'), pn)
	end
	-- player proxies
	for pn = 1, #PP do
		PP[pn]:SetTarget(P[pn])
		P[pn]:hidden(1)
	end
	-- your code goes here here:

	local function lerp(x, y, a)
		return x * (1 - a) + y * a
	end
	local function clamp(a, x, y)
		return math.min(math.max(a, math.min(x, y)), math.max(x, y))
	end
	
	--define scalex and scaley
	local padding = 12 -- in px
	local size = math.min(sw, sh) - padding
	local padleft = scx - size/2
	local padtop = scy - size/2

	print(padtop)
	
	--load chess engine
	local songName = GAMESTATE:GetCurrentSong():GetSongDir();
	local result = pcall(function () dofile ('.' .. songName .. 'lua/sunfish/sunfish.lua') end)
	if not result then result = pcall(function () dofile ('lua/sunfish/sunfish.lua') end) end
	if not result then backToSongWheel('Loading sunfish.lua failed!') end
	
	
	--start chess game
	pos = Position.new(initial, 0, {true,true}, {true,true}, 0, 0)
	printboard(pos.board)
	
	--set sprite layers to not animate
	piece:animate(0)
	boardtile:animate(0)
	piece:zoom(0.5)
	
	local function drawpiece(p,x,y)
		piece:x(x)
		piece:y(y)
		piece:setstate(p)
		piece:Draw()
	end
	local function drawtile(p,x,y)
		boardtile:x(x)
		boardtile:y(y)
		boardtile:zoomto(size / 8, size / 8)
		boardtile:align(0, 0)
		boardtile:setstate(p)
		boardtile:Draw()
	end
	local function drawboard(bx,by)
		bx = bx or 0
		by = by or 0
		for x=0,7 do
			for y=0,7 do
				-- in the case of a non 4:3 aspect ratio, scaley is usually smaller.
				drawtile((x + y) % 2, padleft + size * x/8, padtop + size * y/8)
			end
		end
	end

	local cursorx, cursory = 0, 0
	local cursorxto, cursoryto = 0, 0

	-- squircle rendering code (oh god please help)
	local corners = {{0, 0}, {1, 0}, {1, 1}, {0, 1}}
	local cursorVertices = {}
	local radius = 0.14
	local q = 6
	for i = 1, 4 do
		for a = 0, q do
			local angle = (a / q) * math.pi / 2 + (i + 1) * math.pi / 2
			local ox = corners[i][1]
			local oy = corners[i][2]
			local x = math.cos(angle) * radius + ((ox - 0.5) * (1 - radius * 2) + 0.5)
			local y = math.sin(angle) * radius + ((oy - 0.5) * (1 - radius * 2) + 0.5)
			table.insert(cursorVertices, {x = x, y = y})
		end
	end
	table.insert(cursorVertices, cursorVertices[1])

	cursor:SetNumVertices(#cursorVertices)
	for i, v in pairs(cursorVertices) do
		print(v.x, v.y)
		cursor:SetVertexPosition(i - 1, v.x, v.y, 0)
	end
	cursor:SetDrawMode('linestrip')

	local function drawcursor(x, y)
		cursor:xy(x, y)
		cursor:diffuse(129/255, 241/255, 245/255, 1)
		cursor:zoom(size / 8)
		cursor:SetLineWidth(3)
		cursor:Draw()
	end
	
	local lasttime = 0
	chess:SetDrawFunction(function(self)
		local dt = GAMESTATE:GetSongTime() - lasttime
		lasttime = GAMESTATE:GetSongTime()

		cursorx, cursory = lerp(cursorx, cursorxto, dt * 12), lerp(cursory, cursoryto, dt * 12)

		drawboard()
		drawcursor(padleft + size * cursorx / 8, padtop + size * cursory / 8)
		--for i=0,11 do
			--drawpiece(i,i*50+50,SCREEN_HEIGHT/2+math.sin(i)*50)
		--end
	end)
	
	
	-- setup input
	local dirbinds = {
		Left = {-1, 0},
		Down = {0, 1},
		Up = {0, -1},
		Right = {1, 0},
	}
	local holdtimer = 0.75 -- how many seconds does it take before a key tap becomes a long tap?
	for _, v in ipairs({'Left', 'Down', 'Up', 'Right'}) do
		local v = v
		local d = dirbinds[v]
		Trace(v)
		local pressedAt = -1
		self:addcommand('StepP' .. 1 .. v .. 'Press' .. 'Message', function()
			pressedAt = GAMESTATE:GetSongTime()
		end)
		self:addcommand('StepP' .. 1 .. v .. 'Lift' .. 'Message', function()
			local dt = GAMESTATE:GetSongTime() - pressedAt
			if dt < holdtimer then
				Trace('moved cursor ' .. v .. '!')
				cursorxto, cursoryto = clamp(cursorxto + d[1], 0, 7), clamp(cursoryto + d[2], 0, 7)
				pressedAt = -1
			end
		end)

		func {0, 9e9, function()
			if pressedAt == -1 then return end
			local dt = GAMESTATE:GetSongTime() - pressedAt
			if dt >= holdtimer then
				Trace('holding piece!')
				pressedAt = -1
			end
		end}
	end
end)"
Type = "ActorFrame"
><children>
	<Layer Type = "ActorProxy" Name = "PC[1]" />
	<Layer Type = "ActorProxy" Name = "PC[2]" />
	<Layer Type = "ActorProxy" Name = "PJ[1]" />
	<Layer Type = "ActorProxy" Name = "PJ[2]" />
	<Layer Type = "ActorProxy" Name = "PP[1]" />
	<Layer Type = "ActorProxy" Name = "PP[2]" />
	
	<Layer Type = "ActorFrame" Name = "chess"> <children>
		<Layer File = 'chess.sprite' Name = "piece" />
		<Layer File = 'board.sprite' Name = "boardtile" />
		<Layer Type = "Polygon" Name = "cursor" />
	</children> </Layer>
</children></Mods>
