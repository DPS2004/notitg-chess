<Mods LoadCommand = "%xero(function(self)
	if not P1 or not P2 then
		backToSongWheel('Two Player Mode Required')
		return
	end

	GAMESTATE:ForceSmoothLines(1)

	-- judgment / combo proxies
	for pn = 1, 2 do
		setupJudgeProxy(PJ[pn], P[pn]:GetChild('Judgment'), pn)
		setupJudgeProxy(PC[pn], P[pn]:GetChild('Combo'), pn)
	end
	-- player proxies
	for pn = 1, #PP do
		PP[pn]:SetTarget(P[pn])
		P[pn]:hidden(1)
	end
	-- your code goes here here:

	local function lerp(x, y, a)
		return x * (1 - a) + y * a
	end
	local function clamp(a, x, y)
		return math.min(math.max(a, math.min(x, y)), math.max(x, y))
	end
	
	--define scalex and scaley
	local padding = 12 -- in px
	local size = math.min(sw, sh) - padding
	local padleft = scx - size/2
	local padtop = scy - size/2

	print(padtop)
	
	--set chess engine difficulty
	local difficulty = GAMESTATE:GetCurrentSteps(0):GetDifficulty()
	if difficulty == 1 then
		NODES_SEARCHED = 1e1
	elseif difficulty == 2 then
		NODES_SEARCHED = 1e2
	elseif difficulty == 3 then
		NODES_SEARCHED = 1e3
	elseif difficulty == 4 then
		NODES_SEARCHED = 1e4
	end
	print('difficulty '.. difficulty)
	
	--load chess engine
	local songName = GAMESTATE:GetCurrentSong():GetSongDir();
	local result = pcall(function () dofile ('.' .. songName .. 'lua/sunfish/sunfish.lua') end)
	if not result then result = pcall(function () dofile ('lua/sunfish/sunfish.lua') end) end
	if not result then backToSongWheel('Loading sunfish.lua failed!') end
	
	
	
	--start chess game
	pos = Position.new(initial, 0, {true,true}, {true,true}, 0, 0)
	printboard(pos.board)
	board = boardtotable(pos.board) --only call this when board needs to be updated
	
	--set sprite layers to not animate
	piece:animate(0)
	boardtile:animate(0)
	piece:zoomto(size / 8, size / 8)
	piece:align(0, 0)
	boardtile:zoomto(size / 8, size / 8)
	boardtile:align(0, 0)
	
	local function drawpiece(p,x,y,o)
		o = o or 1
		piece:x(x)
		piece:y(y)
		piece:diffusealpha(o)
		piece:setstate(p)
		piece:Draw()
	end
	local function drawtile(p,x,y)
		boardtile:x(x)
		boardtile:y(y)
		
		boardtile:setstate(p)
		boardtile:Draw()
	end
	local function drawboard(bx,by)
		bx = bx or 0
		by = by or 0
		for x=0,7 do
			for y=0,7 do
				-- in the case of a non 4:3 aspect ratio, scaley is usually smaller.
				drawtile((x + y) % 2, padleft + size * x/8, padtop + size * y/8)
			end
		end
	end
	
	
	
	local pstrtopnum = {
		K = 0,
		Q = 1,
		B = 2,
		N = 3,
		R = 4,
		P = 5,
		k = 6,
		q = 7,
		b = 8,
		n = 9,
		r = 10,
		p = 11
	}
	
	local heldpiece = {x=-1,y=-1}
	
	local wobblesize = 0.1
	
	local function drawpieces(bx,by)
		bx = bx or 0
		by = by or 0
		for x=0,7 do
			for y=0,7 do
				local cpiece = pstrtopnum[ board[x+1][y+1] ] 
				if cpiece then
					if x == heldpiece.x and y == heldpiece.y then
						drawpiece(cpiece, padleft + size * x/8, padtop + size * (y + math.sin(GAMESTATE:GetSongTime()*1.5)*wobblesize)/8,0.5)
					else
						drawpiece(cpiece, padleft + size * x/8, padtop + size * y/8)
					end
				end
			end
		end
	end

	local cursorx, cursory = 0, 0
	local cursorxto, cursoryto = 0, 0
	


	-- squircle rendering code (oh god please help)
	local corners = {{0, 0}, {1, 0}, {1, 1}, {0, 1}}
	local cursorVertices = {}
	local radius = 0.14
	local q = 6
	for i = 1, 4 do
		for a = 0, q do
			local angle = (a / q) * math.pi / 2 + (i + 1) * math.pi / 2
			local ox = corners[i][1]
			local oy = corners[i][2]
			local x = math.cos(angle) * radius + ((ox - 0.5) * (1 - radius * 2) + 0.5)
			local y = math.sin(angle) * radius + ((oy - 0.5) * (1 - radius * 2) + 0.5)
			table.insert(cursorVertices, {x = x, y = y})
		end
	end
	table.insert(cursorVertices, cursorVertices[1])

	cursor:SetNumVertices(#cursorVertices)
	for i, v in pairs(cursorVertices) do
		print(v.x, v.y)
		cursor:SetVertexPosition(i - 1, v.x, v.y, 0)
	end
	cursor:SetDrawMode('linestrip')

	local function drawcursor(x, y)
		cursor:xy(x, y)
		cursor:diffuse(129/255, 241/255, 245/255, 1)
		cursor:zoom(size / 8)
		cursor:SetLineWidth(3)
		cursor:Draw()
		if heldpiece.x ~= -1 and heldpiece.y ~= -1 then
			local cpiece = pstrtopnum[ board[heldpiece.x+1][heldpiece.y+1] ] 
			drawpiece(cpiece ,x, y + (math.sin(GAMESTATE:GetSongTime()*1.5)*(0-wobblesize))*80,0.5)
		end
	end
	
	local lasttime = 0
	chess:SetDrawFunction(function(self)
		local dt = GAMESTATE:GetSongTime() - lasttime
		lasttime = GAMESTATE:GetSongTime()

		cursorx, cursory = lerp(cursorx, cursorxto, dt * 12), lerp(cursory, cursoryto, dt * 12)

		drawboard()
		drawpieces()
		drawcursor(padleft + size * cursorx / 8, padtop + size * cursory / 8)
		--for i=0,11 do
			--drawpiece(i,i*50+50,SCREEN_HEIGHT/2+math.sin(i)*50)
		--end
	end)
	
	
	local sfletters = {'a','b','c','d','e','f','g','h'}
	
	-- setup input
	local dirbinds = {
		Left = {-1, 0},
		Down = {0, 1},
		Up = {0, -1},
		Right = {1, 0},
	}
	local holdtimer = 0.75 -- how many seconds does it take before a key tap becomes a long tap?
	for _, v in ipairs({'Left', 'Down', 'Up', 'Right'}) do
		local v = v
		local d = dirbinds[v]
		Trace(v)
		local pressedAt = -1
		self:addcommand('StepP' .. 1 .. v .. 'Press' .. 'Message', function()
			pressedAt = GAMESTATE:GetSongTime()
		end)
		self:addcommand('StepP' .. 1 .. v .. 'Lift' .. 'Message', function()
			local dt = GAMESTATE:GetSongTime() - pressedAt
			if dt < holdtimer then
				Trace('moved cursor ' .. v .. '!')
				cursorxto, cursoryto = clamp(cursorxto + d[1], 0, 7), clamp(cursoryto + d[2], 0, 7)
				pressedAt = -1
			end
		end)

		func {0, 9e9, function()
			if pressedAt == -1 then return end
			local dt = GAMESTATE:GetSongTime() - pressedAt
			if dt >= holdtimer then
				Trace('holding piece!')
				
				pressedAt = -1
				if heldpiece.x == cursorxto and heldpiece.y == cursoryto then -- holding on already selected piece, unselect
					heldpiece.x = -1
					heldpiece.y = -1
				elseif heldpiece.x == -1 and heldpiece.y == -1 and pstrtopnum[ board[cursorxto+1][cursoryto+1] ]  then -- no held piece, select current piece
					heldpiece.x = cursorxto
					heldpiece.y = cursoryto
				elseif heldpiece.x ~= -1 and heldpiece.y ~= -1  then-- selecting a different piece with an already held piece, try to move held piece to this spot!
					local crdn = sfletters[heldpiece.x + 1] .. tostring(8 - heldpiece.y) .. sfletters[cursorxto + 1] .. tostring(8 - cursoryto) 
					-- this generates a move string that sunfish accepts (eg: a2a3)
					local move = {parse(string.sub(crdn, 1, 2)), parse(string.sub(crdn, 3, 4))}
					if move[1] and move[2] and ttfind(pos:genMoves(), move) then
						print('this is an ok move')
						pos = pos:move(move)
						
						local move, score = search(pos)
						assert(score)
						
						if score <= -MATE_VALUE then
							print('You won')
						end
						if score >= MATE_VALUE then
							print('You lost')
						end
						
						assert(move)
						
						pos = pos:move(move)
						
						board = boardtotable(pos.board)
						
						heldpiece.x = -1
						heldpiece.y = -1
					else
						print('this is NOT an ok move!!!')
					end
				end
				print(heldpiece.x)
				print(heldpiece.y)
			end
		end}
	end
end)"
Type = "ActorFrame"
><children>
	<Layer Type = "ActorProxy" Name = "PC[1]" />
	<Layer Type = "ActorProxy" Name = "PC[2]" />
	<Layer Type = "ActorProxy" Name = "PJ[1]" />
	<Layer Type = "ActorProxy" Name = "PJ[2]" />
	<Layer Type = "ActorProxy" Name = "PP[1]" />
	<Layer Type = "ActorProxy" Name = "PP[2]" />
	
	<Layer Type = "ActorFrame" Name = "chess"> <children>
		<Layer File = 'chess.sprite' Name = "piece" />
		<Layer File = 'board.sprite' Name = "boardtile" />
		<Layer Type = "Polygon" Name = "cursor" />
	</children> </Layer>
</children></Mods>
