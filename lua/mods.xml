<Mods LoadCommand = "%xero(function(self)
	if not P1 or not P2 then
		backToSongWheel('Two Player Mode Required')
		return
	end

	GAMESTATE:ForceSmoothLines(1)

	-- judgment / combo proxies
	for pn = 1, 2 do
		setupJudgeProxy(PJ[pn], P[pn]:GetChild('Judgment'), pn)
		setupJudgeProxy(PC[pn], P[pn]:GetChild('Combo'), pn)
	end
	-- player proxies
	for pn = 1, #PP do
		PP[pn]:SetTarget(P[pn])
		P[pn]:hidden(1)
	end
	-- your code goes here here:
	
	setdefault { 
		200, 'tiny0',
		200,'tiny1',
		200,'tiny3',
		128,'x',
		64,'y'
	}
	P[2]:hidden(1)
	gamestate = 0
	
	--set nearest neighbor for certain sprites
	piecespr[2]:SetTextureFiltering(false)
	piecespr[7]:SetTextureFiltering(false)
	
	skintext:x(SCREEN_WIDTH/2)
	skintext:y(SCREEN_HEIGHT/1.4)
	skintext:zoom(0.5)
	
	badmovetext:x(SCREEN_WIDTH/2)
	badmovetext:y(SCREEN_HEIGHT/2)
	badmovetext:vibrate()
	badmovetext:glow(1,0,0,1)
	badmovetimer = 0
	firstbadmove = true
	youfuckedup = {
		'NOPE',
		'TRY AGAIN',
		'THINK FAST CHUCKLENUTS',
		'133.221.26.29',
		'YOU FUCKED UP',
		'ACCESS VIOLATION',
		'CAR???',
		'KONAMI WILL SUE',
		'IT\'S A FEATURE',
		'FORBIDDEN',
		'BRING ME HANK',
		'UNINSTALL AVAST',
		'ASDFGHJKL;',
		'START RUNNING',
		'>:(',
	}

	local function lerp(x, y, a)
		return x * (1 - a) + y * a
	end
	local function clamp(a, x, y)
		return math.min(math.max(a, math.min(x, y)), math.max(x, y))
	end
	
	--define scalex and scaley
	local padding = 12 -- in px
	local size = math.min(sw, sh) - padding
	local padleft = scx - size/2
	local padtop = scy - size/2

	print(padtop)
	
	--set chess engine difficulty
	local difficulty = GAMESTATE:GetCurrentSteps(0):GetDifficulty()
	if difficulty == 1 then
		NODES_SEARCHED = 1e1
	elseif difficulty == 2 then
		NODES_SEARCHED = 1e2
	elseif difficulty == 3 then
		NODES_SEARCHED = 1e3
	elseif difficulty == 4 then
		NODES_SEARCHED = 1e4
	end
	print('difficulty '.. difficulty)
	
	--load chess engine
	local songName = GAMESTATE:GetCurrentSong():GetSongDir();
	local result = pcall(function () dofile ('.' .. songName .. 'lua/sunfish/sunfish.lua') end)
	if not result then result = pcall(function () dofile ('lua/sunfish/sunfish.lua') end) end
	if not result then backToSongWheel('Loading sunfish.lua failed!') end
	
	
	
	--start chess game
	pos = Position.new(initial, 0, {true,true}, {true,true}, 0, 0)
	printboard(pos.board)
	board = boardtotable(pos.board) --only call this when board needs to be updated
	
	--set sprite layers to not animate
	
	function initpiecespr()
	
		piece:animate(0)
		piece:zoomto(size / 8, size / 8)
		--piece:align(0, 0)
	end
	boardtile:animate(0)
	boardtile:zoomto(size / 8, size / 8)
	boardtile:align(0, 0)
	
	local function drawpiece(p,x,y,o,r)
		o = o or 1
		piece:x(x + 0.5 * size/8)
		piece:y(y + 0.5 * size/8)
		piece:rotationz(r or 0)
		piece:diffusealpha(o)
		piece:setstate(p)
		piece:Draw()
	end
	local function drawtile(p,x,y)
		boardtile:x(x)
		boardtile:y(y)
		
		boardtile:setstate(p)
		boardtile:Draw()
	end
	local function drawboard(bx,by)
		bx = bx or 0
		by = by or 0
		for x=0,7 do
			for y=0,7 do
				-- in the case of a non 4:3 aspect ratio, scaley is usually smaller.
				drawtile((x + y) % 2, padleft + size * x/8, padtop + size * y/8)
			end
		end
	end
	
	
	
	local pstrtopnum = {
		K = 0,
		Q = 1,
		B = 2,
		N = 3,
		R = 4,
		P = 5,
		k = 6,
		q = 7,
		b = 8,
		n = 9,
		r = 10,
		p = 11
	}

	local sfletters = {'a','b','c','d','e','f','g','h'}
	
	local heldpiece = {x=-1,y=-1,dx=-1,dy=-1}
	local heldanim = 0
	local heldanimto = 0
	local heldcpiece
	
	local wobblesize = 0.1
	easedpieces = {}
	local function drawpieces(bx,by)
		bx = bx or 0
		by = by or 0
		for x=0,7 do
			for y=0,7 do
				local cpiece = pstrtopnum[ board[x+1][y+1] ] 
				if cpiece then
					if x == heldpiece.x and y == heldpiece.y then
						drawpiece(cpiece, padleft + size * x/8, padtop + size * (y + lerp(0, math.sin(GAMESTATE:GetSongTime()*1.5)*wobblesize, heldanim))/8, lerp(1, 0.5, heldanim))
					else
						local dodraw = true
						for i,v in ipairs(easedpieces) do
							if x == v.x and y == v.y then
								dodraw = false
							end
						end
						if dodraw then
							drawpiece(cpiece, padleft + size * x/8, padtop + size * y/8)
						end
					end
				end
			end
		end
		local easestoremove = {}
		for i,v in ipairs(easedpieces) do
			drawpiece(v.p, padleft + size * v.cx/8, padtop + size * v.cy/8)
			
			easedpieces[i].cx = lerp(easedpieces[i].cx, easedpieces[i].x, 0.1)
			easedpieces[i].cy = lerp(easedpieces[i].cy, easedpieces[i].y, 0.1)
			easedpieces[i].t = easedpieces[i].t + 1
			if easedpieces[i].t >= 100 then
				table.insert(easestoremove,i)
			end
		end
		for i,v in ipairs(easestoremove) do
			table.remove(easedpieces,v-i+1)
		end
	end

	local cursorx, cursory = 3, 6
	local cursorxto, cursoryto = 3, 6
	local cursorzoom, cursorzoomto = 1, 1
	local cursorholdstart = -1
	local holdtimer = 0.5 -- how many seconds does it take before a key tap becomes a long tap?

	-- squircle rendering code (oh god please help)
	local corners = {{0, 0}, {1, 0}, {1, 1}, {0, 1}}
	local cursorVertices = {}
	local radius = 0.14
	local q = 6
	for i = 1, 4 do
		for a = 0, q do
			local angle = (a / q) * math.pi / 2 + (i + 1) * math.pi / 2
			local ox = corners[i][1]
			local oy = corners[i][2]
			local x = math.cos(angle) * radius + ((ox - 0.5) * (1 - radius * 2) + 0.5)
			local y = math.sin(angle) * radius + ((oy - 0.5) * (1 - radius * 2) + 0.5)
			table.insert(cursorVertices, {x = x, y = y})
		end
	end
	table.insert(cursorVertices, cursorVertices[1])

	cursor:SetNumVertices(#cursorVertices)
	for i, v in pairs(cursorVertices) do
		print(v.x, v.y)
		cursor:SetVertexPosition(i - 1, v.x, v.y, 0)
	end
	cursor:SetDrawMode('linestrip')
	cursor:SetPolygonMode(1)

	local circleq = 50
	local circlesize = 0
	local circlesizeto = 0
	movespot:SetNumVertices(circleq)
	for i = 1, circleq do
		local a = i / (circleq - 1) * math.pi * 2
		movespot:SetVertexPosition(i - 1, math.cos(a), math.sin(a), 0)
	end
	movespot:SetDrawMode('fan')
	movespot:SetPolygonMode(0)

	local function drawcursor(x, y)
		local bri = math.sin(GAMESTATE:GetSongTime() * 3) * 0.05 - 0.1
		cursor:diffuse(129/255 + bri, 241/255 + bri, 245/255 + bri, 1)
		if cursorholdstart ~= -1 then
			cursorzoomto = 1 - ((GAMESTATE:GetSongTime() - cursorholdstart) / holdtimer) * 0.25
		else
			cursorzoomto = 1
		end
		cursor:zoom(size / 8 * cursorzoom)
		local zoomoffset = (1 - cursorzoom) * size / 8 / 2
		cursor:xy(x + zoomoffset, y + zoomoffset)
		cursor:SetLineWidth(3)
		cursor:Draw()
		if heldanim > 0.1 then
			drawpiece(heldcpiece, padleft + size * heldpiece.dx / 8, (padtop + size * heldpiece.dy / 8) + lerp(0, math.sin(GAMESTATE:GetSongTime()*1.5)*(0-wobblesize), heldanim)*80,0.5, (heldpiece.dx - lerp(heldpiece.dx, cursorxto, -0.01)) * 1000)
		end
	end

	local movespotsCache = {}
	local function drawMovespots()
		if #movespotsCache == 0 then
			for x = 0, 7 do
				for y = 0, 7 do
					local crdn = sfletters[heldpiece.x + 1] .. tostring(8 - heldpiece.y) .. sfletters[x + 1] .. tostring(8 - y)
					-- this generates a move string that sunfish accepts (eg: a2a3)
					local move = {parse(string.sub(crdn, 1, 2)), parse(string.sub(crdn, 3, 4))}
					local valid = move[1] and move[2] and ttfind(pos:genMoves(), move)

					if valid then
						table.insert(movespotsCache, {x, y})
					end
				end
			end
		end

		movespot:zoom(size / 8 / 6 * circlesize)
		movespot:SetLineWidth(4)
		for _, s in ipairs(movespotsCache) do
			local cpiece = pstrtopnum[ board[s[1]+1][s[2]+1] ]
			if cpiece then
				movespot:diffuse(1, 0, 0, 0.5)
			else
				movespot:diffuse(1, 1, 1, 0.5)
			end

			movespot:xy(padleft + size * (s[1] + 0.5) / 8, padtop + size * (s[2] + 0.5) / 8)
			movespot:Draw()
		end
	end
	
	local sproptions = {'wiki','pico','boring','plastic','dunno','geometric','fantasy'}
	local sprselection = 1
	local lasttime = 0
	chess:SetDrawFunction(function(self)
		local dt = GAMESTATE:GetSongTime() - lasttime
		lasttime = GAMESTATE:GetSongTime()
		if gamestate == 1 then
			cursorx, cursory = lerp(cursorx, cursorxto, dt * 12), lerp(cursory, cursoryto, dt * 12)
			cursorzoom = lerp(cursorzoom, cursorzoomto, dt * 17)
			circlesize = lerp(circlesize, circlesizeto, dt * 18)
			heldanim = lerp(heldanim, heldanimto, dt * 10)
			heldpiece.dx, heldpiece.dy = lerp(heldpiece.dx, cursorxto, dt * 6), lerp(heldpiece.dy, cursoryto, dt * 6)
		end
		drawboard()
		if gamestate == 1 then
			drawpieces()
			if heldanim > 0.1 or circlesize > 0.1 then
				drawMovespots()
			end
			drawcursor(padleft + size * cursorx / 8, padtop + size * cursory / 8)
		end
		--for i=0,11 do
			--drawpiece(i,i*50+50,SCREEN_HEIGHT/2+math.sin(i)*50)
		--end
		if gamestate == 0 then
			for i,v in ipairs(sproptions) do
				piece = piecespr[i]
				drawpiece(3,(i-sprselection+3.11)*size*0.2,SCREEN_HEIGHT/2)
			end
		end
	end)

	-- setup input
	local dirbinds = {
		Left = {-1, 0},
		Down = {0, 1},
		Up = {0, -1},
		Right = {1, 0},
	}
	for _, v in ipairs({'Left', 'Down', 'Up', 'Right'}) do
		local v = v
		local d = dirbinds[v]
		Trace(v)
		local pressedAt = -1
		self:addcommand('StepP' .. 1 .. v .. 'Press' .. 'Message', function()
			pressedAt = GAMESTATE:GetSongTime()
			cursorholdstart = pressedAt
			if gamestate == 0 then
				sprselection = clamp(sprselection + d[1], 1, #sproptions)
				skintext:settext(sproptions[sprselection])
				if d[2] == -1 then
					gamestate = 1
					piece = piecespr[sprselection]
					skintext:settext('')
					PP[1]:hidden(1)
					initpiecespr()
				end
			end
		end)
		self:addcommand('StepP' .. 1 .. v .. 'Lift' .. 'Message', function()
			local dt = GAMESTATE:GetSongTime() - pressedAt

			if dt < holdtimer then
				if gamestate == 1 then
					Trace('moved cursor ' .. v .. '!')
					cursorxto, cursoryto = clamp(cursorxto + d[1], 0, 7), clamp(cursoryto + d[2], 0, 7)
				end
				pressedAt = -1
				cursorholdstart = -1
			end
		end)

		func {0, 9e9, function()
			if gamestate == 1 then	
				if pressedAt == -1 then return end
				local dt = GAMESTATE:GetSongTime() - pressedAt
				if dt >= holdtimer then
					Trace('holding piece!')
					
					pressedAt = -1
					cursorholdstart = -1
					if heldpiece.x == cursorxto and heldpiece.y == cursoryto and heldanimto == 1 then -- holding on already selected piece, unselect
						circlesizeto = 0
						heldanimto = 0
					elseif heldanimto == 0 and pstrtopnum[ board[cursorxto+1][cursoryto+1] ]  then -- no held piece, select current piece
						heldpiece.x = cursorxto
						heldpiece.y = cursoryto
						heldpiece.dx = cursorxto
						heldpiece.dy = cursoryto
						circlesizeto = 1
						heldanimto = 1
						movespotsCache = {}
						heldcpiece = pstrtopnum[ board[heldpiece.x+1][heldpiece.y+1] ]
					elseif heldanimto == 1 then-- selecting a different piece with an already held piece, try to move held piece to this spot!
						local crdn = sfletters[heldpiece.x + 1] .. tostring(8 - heldpiece.y) .. sfletters[cursorxto + 1] .. tostring(8 - cursoryto) 
						-- this generates a move string that sunfish accepts (eg: a2a3)
						local move = {parse(string.sub(crdn, 1, 2)), parse(string.sub(crdn, 3, 4))}
						if move[1] and move[2] and ttfind(pos:genMoves(), move) then

							print('this is an ok move')
							pos = pos:move(move)
							print(move[1])
							print(move[2])
							
							print(move[1]%10)
							print(math.floor(move[1]/10)-1)
							table.insert(easedpieces,{
								x= move[2]%10 - 1, y= math.floor(move[2]/10) - 2, 
								cx= move[1]%10 - 1, cy= math.floor(move[1]/10) - 2,
								t = 0,
								p = pstrtopnum[ board[move[1]%10][math.floor(move[1]/10)-1] ]
								
							})
							
							local move, score = search(pos)
							assert(score)
							
							if score <= -MATE_VALUE then
								print('You won')
							end
							if score >= MATE_VALUE then
								print('You lost')
							end
							
							assert(move)
							
							pos = pos:move(move)
							
							board = boardtotable(pos.board)
							
							circlesizeto = 0
							heldanimto = 0
						else
							print('this is NOT an ok move!!!')
							badmovetimer = 100
							if firstbadmove then
								badmovetext:settext('ILLEGAL MOVE')
								firstbadmove = false
							else
								badmovetext:settext(youfuckedup[math.random(1,#youfuckedup)])
							end
						end
					end
					print(heldpiece.x)
					print(heldpiece.y)
				end
			end
		end}
		
	end
	func {0, 9e9, function() 
		if badmovetimer > 0 then
			badmovetimer = badmovetimer - 1
			if badmovetimer <= 0 then
				badmovetext:settext('')
			end
		end
	end}
	

end)"
Type = "ActorFrame"
><children>
	<Layer Type = "ActorProxy" Name = "PC[1]" />
	<Layer Type = "ActorProxy" Name = "PC[2]" />
	<Layer Type = "ActorProxy" Name = "PJ[1]" />
	<Layer Type = "ActorProxy" Name = "PJ[2]" />

	
	<Layer Type = "ActorFrame" Name = "chess"> <children>
		<Layer File = 'wiki.sprite' Name = "piecespr[1]" />
		<Layer File = 'pico.sprite' Name = "piecespr[2]" />
		<Layer File = 'boring.sprite' Name = "piecespr[3]" />
		<Layer File = 'plastic.sprite' Name = "piecespr[4]" />
		<Layer File = 'dunno.sprite' Name = "piecespr[5]" />
		<Layer File = 'geometric.sprite' Name = "piecespr[6]" />
		<Layer File = 'fantasy.sprite' Name = "piecespr[7]" />
		<Layer File = 'board.sprite' Name = "boardtile" />
		<Layer Type = "Polygon" Name = "cursor" />
		<Layer Type = "Polygon" Name = "movespot" />
	</children> </Layer>
	<Layer Name = "badmovetext" Type="BitmapText" Font="_wendy small" Text=""/>
	<Layer Name = "skintext" Type="BitmapText" Font="_wendy small" Text="wiki"/>
	<Layer Type = "ActorProxy" Name = "PP[1]" />

</children></Mods>
